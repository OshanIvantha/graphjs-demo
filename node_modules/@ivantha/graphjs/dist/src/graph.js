'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _chartType = require('./charts/chart-type');

var _chartType2 = _interopRequireDefault(_chartType);

var _lineChart = require('./charts/types/line-chart');

var _lineChart2 = _interopRequireDefault(_lineChart);

var _simpleXyLineChart = require('./charts/types/simple-xy-line-chart');

var _simpleXyLineChart2 = _interopRequireDefault(_simpleXyLineChart);

var _stepChart = require('./charts/types/step-chart');

var _stepChart2 = _interopRequireDefault(_stepChart);

var _barChart = require('./charts/types/bar-chart');

var _barChart2 = _interopRequireDefault(_barChart);

var _pieChart = require('./charts/types/pie-chart');

var _pieChart2 = _interopRequireDefault(_pieChart);

var _multipleXyLineChart = require('./charts/types/multiple-xy-line-chart');

var _multipleXyLineChart2 = _interopRequireDefault(_multipleXyLineChart);

var _areaChart = require('./charts/types/area-chart');

var _areaChart2 = _interopRequireDefault(_areaChart);

var _stackedBarChart = require('./charts/types/stacked-bar-chart');

var _stackedBarChart2 = _interopRequireDefault(_stackedBarChart);

var _donutChart = require('./charts/types/donut-chart');

var _donutChart2 = _interopRequireDefault(_donutChart);

var _splineChart = require('./charts/types/spline-chart');

var _splineChart2 = _interopRequireDefault(_splineChart);

var _stackedAreaChart = require('./charts/types/stacked-area-chart');

var _stackedAreaChart2 = _interopRequireDefault(_stackedAreaChart);

var _scatterPlot = require('./charts/types/scatter-plot');

var _scatterPlot2 = _interopRequireDefault(_scatterPlot);

var _invalidGrammarError = require('./errors/invalid-grammar-error');

var _invalidGrammarError2 = _interopRequireDefault(_invalidGrammarError);

var _invalidOperationError = require('./errors/invalid-operation-error');

var _invalidOperationError2 = _interopRequireDefault(_invalidOperationError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Graph is the base class of all operations withing the GraphJS.
 * It acts as a factory-pattern for creating any types of charts.
 */
var Graph = function () {

	/**
  * Creates an instance of the class Graph
  * @param {string} grammar - Initial grammar provided to initiate the class.
  * This should be in the form of : generate <GRAPH_TYPE> for <DATASOURCE>
  */
	function Graph(grammar) {
		_classCallCheck(this, Graph);

		/**
   * Holds the instance of the charts types that was created within the object with the initial grammar.
   * @types {Chart}
   * @private
   */
		this._chart = undefined;

		// Validate and parse the grammar
		var grammarParser = new GrammarParser(grammar);

		var chartType = grammarParser.chartType;
		switch (_chartType2.default.enumValueOf(chartType)) {
			case _chartType2.default.LINE_CHART:
				this._chart = new _lineChart2.default(grammarParser.datasource);
				break;
			case _chartType2.default.SIMPLE_XY_LINE_CHART:
				this._chart = new _simpleXyLineChart2.default(grammarParser.datasource);
				break;
			case _chartType2.default.STEP_CHART:
				this._chart = new _stepChart2.default(grammarParser.datasource);
				break;
			case _chartType2.default.BAR_CHART:
				this._chart = new _barChart2.default(grammarParser.datasource);
				break;
			case _chartType2.default.PIE_CHART:
				this._chart = new _pieChart2.default(grammarParser.datasource);
				break;
			case _chartType2.default.COMBINATION_CHART:
				throw new _invalidOperationError2.default();
			// this._chart = new CombinationChart(grammarParser.datasource)
			// break
			case _chartType2.default.MULTIPLE_XY_LINE_CHART:
				this._chart = new _multipleXyLineChart2.default(grammarParser.datasource);
				break;
			case _chartType2.default.AREA_CHART:
				this._chart = new _areaChart2.default(grammarParser.datasource);
				break;
			case _chartType2.default.STACKED_BAR_CHART:
				this._chart = new _stackedBarChart2.default(grammarParser.datasource);
				break;
			case _chartType2.default.DONUT_CHART:
				this._chart = new _donutChart2.default(grammarParser.datasource);
				break;
			case _chartType2.default.SPLINE_CHART:
				this._chart = new _splineChart2.default(grammarParser.datasource);
				break;
			case _chartType2.default.LINE_CHART_WITH_REGIONS:
				throw new _invalidOperationError2.default();
			// this._chart = new LineChartWithRegions(grammarParser.datasource)
			// break
			case _chartType2.default.STACKED_AREA_CHART:
				this._chart = new _stackedAreaChart2.default(grammarParser.datasource);
				break;
			case _chartType2.default.SCATTER_PLOT:
				this._chart = new _scatterPlot2.default(grammarParser.datasource);
				break;
			case _chartType2.default.GAUGE_CHART:
				throw new _invalidOperationError2.default();
			// this._chart = new GaugeChart(grammarParser.datasource)
			// break
		}
	}

	/**
  * Parse the grammar given by the user.
  * @param grammar
  * @returns {boolean}
  */


	_createClass(Graph, [{
		key: 'do',
		value: function _do(grammar) {
			return this._chart.do(grammar);
		}

		/**
   * Return the JSON output string created by parsing the input grammar.
   * @returns {string}
   */

	}, {
		key: 'generateJson',
		value: function generateJson() {
			return this._chart.generateJson();
		}
	}]);

	return Graph;
}();

/**
 * Does the initial grammar parsing.
 */


exports.default = Graph;

var GrammarParser = function () {

	/**
  * Creates an instance of the class GrammarParser
  * @param {string} grammar - Initial grammar provided to initiate the class.
  * This should be in the form of : generate <GRAPH_TYPE> for <DATASOURCE>
  */
	function GrammarParser(grammar) {
		_classCallCheck(this, GrammarParser);

		this.grammar = grammar;
		this.chartType = undefined;
		this.datasource = undefined;

		// Verify the basic structure of the grammar
		if (GrammarParser.verifyStructure(grammar)) {
			var chartTypeExtract = grammar.match(new RegExp('generate [A-Z_]+ for'))[0];
			this.chartType = chartTypeExtract.slice(9, chartTypeExtract.length - 4);
			this.datasource = grammar.match(new RegExp('for {.*}'))[0].slice(4);

			// Verify the charts types and the datasource
			if (!GrammarParser.verifyChartType(this.chartType) || !GrammarParser.verifyDatasource(this.datasource)) {
				throw new _invalidGrammarError2.default();
			}
		} else {
			throw new _invalidGrammarError2.default();
		}
	}

	/**
  * Verify the syntactical and the symantic validity of the whole grammar sentence.
  * @param grammar
  * @returns {boolean}
  */


	_createClass(GrammarParser, null, [{
		key: 'verifyStructure',
		value: function verifyStructure(grammar) {
			return grammar.match(new RegExp('generate [A-Z_]+ for {.*}'));
		}

		/**
   * Verify the vaidity of the charts types.
   * @param chartType
   * @returns {boolean}
   */

	}, {
		key: 'verifyChartType',
		value: function verifyChartType(chartType) {
			return _chartType2.default.enumValueOf(chartType) instanceof _chartType2.default;
		}

		/**
   * Verify the validity of the datasource.
   * @param grammar
   * @returns {boolean}
   */
		// eslint-disable-next-line no-unused-vars

	}, {
		key: 'verifyDatasource',
		value: function verifyDatasource(grammar) {
			// TODO : Verify datasource
			return true;
		}
	}]);

	return GrammarParser;
}();