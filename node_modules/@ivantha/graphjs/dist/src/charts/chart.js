'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Chart = function () {

	/**
  * Creates an instance of the Chart class
  * @param {string} data - JSON string containing the data columns.
  */
	function Chart(data) {
		_classCallCheck(this, Chart);

		this._data = data;

		// Define output JSON
		this._outputJson = {
			'size': {
				'height': undefined,
				'width': undefined
			},
			'data': {
				'x': undefined,
				'xs': {},
				'columns': [],
				'names': {},
				'types': {},
				'groups': [],
				'type': undefined,
				'labels': false
			},
			'point': {
				'show': true
			},
			'axis': {
				'rotated': false,
				'x': {
					'label': undefined,
					'max': undefined,
					'min': undefined
				},
				'y': {
					'label': undefined,
					'max': undefined,
					'min': undefined
				}
			},
			'grid': {
				'x': {
					'show': false,
					'lines': []
				},
				'y': {
					'show': false,
					'lines': []
				}
			},
			'legend': {
				'show': true,
				'position': 'bottom'
			},
			'tooltip': {
				'show': true,
				'grouped': true
			},
			'subchart': {
				'show': false
			},
			'zoom': {
				'enabled': false
			},
			'bar': {
				'width': {
					'ratio': undefined
				}
			},
			'donut': {
				'title': undefined
			}

			// Add _data
		};var dataJson = JSON.parse(this._data);
		for (var i in dataJson) {
			this._outputJson.data.columns.push([i].concat(_toConsumableArray(dataJson[i])));
		}
	}

	/**
  * Alter the parameters of the charts using the provided grammar.
  * @param {string} grammar - Simple grammar string describing the charts.
  * @returns {boolean} - Returns true if the grammar is parsed.
  */


	_createClass(Chart, [{
		key: 'do',
		value: function _do(grammar) {
			if (grammar.match(new RegExp('(show|hide) grid [xXyY]'))) {
				var option = grammar.match(new RegExp('(show|hide)'))[0];
				var axis = grammar.match(new RegExp('[xXyY]'))[0];
				if (axis.toLowerCase() === 'x') {
					this._outputJson.grid.x.show = option === 'show';
				} else {
					this._outputJson.grid.y.show = option === 'show';
				}
				return true;
			} else if (grammar.match(new RegExp('set gridline [xXyY] at [\\d]+ as [0-9a-zA-Z\\-]+'))) {
				var _axis = grammar.match(new RegExp('gridline [xXyY] at'))[0].split(' ')[1];
				var position = grammar.match(new RegExp('at [\\d]+ as'))[0].split(' ')[1];
				var label = grammar.match(new RegExp('as [0-9a-zA-Z\\-]+'))[0].split(' ')[1];
				if (_axis.toLowerCase() === 'x') {
					this._outputJson.grid.x.lines.push({
						'value': Number(position),
						'text': label
					});
				} else {
					this._outputJson.grid.y.lines.push({
						'value': Number(position),
						'text': label
					});
				}
				return true;
			} else if (grammar.match(new RegExp('set [0-9a-zA-Z\\-]+ data label as [0-9a-zA-Z\\-]+'))) {
				var dataColumn = grammar.match(new RegExp('set [0-9a-zA-Z\\-]+ data'))[0].split(' ')[1];
				var _label = grammar.match(new RegExp('as [0-9a-zA-Z\\-]+'))[0].split(' ')[1];
				this._outputJson.data.names[dataColumn] = _label;
				return true;
			} else if (grammar.match(new RegExp('set [xXyY] axis label as [0-9a-zA-Z\\-]+'))) {
				var _axis2 = grammar.match(new RegExp('[xXyY]'))[0];
				var _label2 = grammar.match(new RegExp('as [0-9a-zA-Z\\-]+'))[0].split(' ')[1];
				if (_axis2.toLowerCase() === 'x') {
					this._outputJson.axis.x.label = _label2;
				} else {
					this._outputJson.axis.y.label = _label2;
				}
				return true;
			} else if (grammar.match(new RegExp('set [xXyY] axis (max|min) as [-]?[\\d]+'))) {
				var _axis3 = grammar.match(new RegExp('[xXyY]'))[0];
				var margin = grammar.match(new RegExp('axis (max|min) as'))[0].split(' ')[1];
				var value = grammar.match(new RegExp('as [-]?[\\d]+'))[0].split(' ')[1];
				if (_axis3.toLowerCase() === 'x') {
					if (margin.toLowerCase() === 'max') {
						this._outputJson.axis.x.max = Number(value);
					} else {
						this._outputJson.axis.x.min = Number(value);
					}
				} else {
					if (margin.toLowerCase() === 'max') {
						this._outputJson.axis.y.max = Number(value);
					} else {
						this._outputJson.axis.y.min = Number(value);
					}
				}
				return true;
			} else if (grammar.match(new RegExp('(show|hide) tooltip'))) {
				var _option = grammar.match(new RegExp('(show|hide)'))[0];
				this._outputJson.tooltip.show = _option === 'show';
				return true;
			} else if (grammar.match(new RegExp('(group|ungroup) tooltip'))) {
				var _option2 = grammar.match(new RegExp('(group|ungroup)'))[0];
				this._outputJson.tooltip.grouped = _option2 === 'group';
				return true;
			} else if (grammar.match(new RegExp('(show|hide) points'))) {
				var _option3 = grammar.match(new RegExp('(show|hide)'))[0];
				this._outputJson.point.show = _option3 === 'show';
				return true;
			} else if (grammar.match(new RegExp('(show|hide) data labels'))) {
				var _option4 = grammar.match(new RegExp('(show|hide)'))[0];
				this._outputJson.data.labels = _option4 === 'show';
				return true;
			} else if (grammar.match(new RegExp('(show|hide) legend'))) {
				var _option5 = grammar.match(new RegExp('(show|hide)'))[0];
				this._outputJson.legend.show = _option5 === 'show';
				return true;
			} else if (grammar.match(new RegExp('(show|hide) subchart'))) {
				var _option6 = grammar.match(new RegExp('(show|hide)'))[0];
				this._outputJson.subchart.show = _option6 === 'show';
				return true;
			} else if (grammar.match(new RegExp('(enable|disable) zoom'))) {
				var _option7 = grammar.match(new RegExp('(enable|disable)'))[0];
				this._outputJson.zoom.enabled = _option7 === 'enable';
				return true;
			} else if (grammar.match(new RegExp('(enable|disable) rotate'))) {
				var _option8 = grammar.match(new RegExp('(enable|disable)'))[0];
				this._outputJson.axis.rotated = _option8 === 'enable';
				return true;
			} else if (grammar.match(new RegExp('move legend to (right|bottom)'))) {
				var _option9 = grammar.match(new RegExp('(left|right|top|bottom)'))[0];
				this._outputJson.legend.position = _option9;
				return true;
			} else if (grammar.match(new RegExp('set (height|width) as [\\d]+'))) {
				var _option10 = grammar.match(new RegExp('(height|width)'))[0];
				var _value = grammar.match(new RegExp('as [\\d]+'))[0].split(' ')[1];
				if (_option10.toLowerCase() === 'height') {
					this._outputJson.size.height = Number(_value);
				} else {
					this._outputJson.size.width = Number(_value);
				}
				return true;
			} else {
				return false;
			}
		}

		/**
   * Return the JSON output string of the constructed charts.
   * @returns {string}
   */

	}, {
		key: 'generateJson',
		value: function generateJson() {
			return this._outputJson;
		}
	}]);

	return Chart;
}();

exports.default = Chart;